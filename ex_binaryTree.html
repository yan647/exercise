<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>学习二叉树</title>
</head>
<body>
	<p>来源：http://www.cnblogs.com/qinche/archive/2013/03/28/2987191.html</p>
</body>
<script type="text/javascript">
    //构造函数
	function Node(){
		this.text='';
		this.leftChild=null;
		this.rightChild=null;
	}

	var str='';
	var charecters={'a','b','c','d','e','f'};
	var len=charecters.length;
	var nodes=new Array();//存放节点的数组

	for(var i=0;i<len;i++){
		var node=new Node();//节点
		node.text=charecters[i];
		nodes.push(node);
	}

	var root=nodes[0];//根节点

    //栈
	function Stack(){
		var stack=new Array();

		//Stack是个函数，是没有push和pop的，只有数组才有的，所以必须自定义
		this.push=function(e){
			stack.push(e);
		}
		this.pop=function(){
			var e=stack[stack.length-1];
			stack.splice(stack.length-1,1);
			return e;
		}
		this.isEmpty=function(){
			if(stack.length<=0){
				return true;
			} else return false;
		}
	}

	var stack=new Stack();
	stack.push(1);
	stack.isEmpty();
	console.log(stack.pop());
	console.log(stack.isEmpty());

    //递归实现
    //非递归效率高，递归代码写出来思路清晰，可读性强
    //索引从最大的开始
	function buildBt1(node,i){
		var leftIndex=2*i+1,rightIndex=2*i+2;//左右孩子节点的索引,即左右孩子节点在节点数组中的位置
		if(leftIndex<charecters.length){
			var childNode=new Node();
			childNode.text=charecters[leftIndex];
			node.leftChild=childNode;
			buildBt1(childNode,leftIndex);//递归创建左孩子，把全部左孩子建完后，再建右孩子
		}
		if(rightIndex<charecters.length){
			var childNode=new Node();
			childNode.text=charecters[rightIndex];
			node.rightChild=childNode;
			buildBt1(childNode,rightIndex);
		}
	}

	//非递归实现
	function buildBt2(){
		index=0;

		while(index<len){
			var leftIndex=2*index+1;
			var rightIndex=2*index+2;
			nodes[index].leftChild=nodes[leftIndex];
			nodes[index].rightChild=nodes[rightIndex];
			index++;
		}
	}

	//遍历
	//先序递归遍历
	function firstIteration(node){
		if(node.leftChild){
			firstIteration(node.leftChild);
		}
		if(node.rightChild){
			firstIteration(node.rightChild);
		}
	}
	firstIteration(root);

	//先序普通遍历
	function notFirstIteration(node){
		var stack=new Stack();
		resultText='';
		stack.push(root);

		var node=root;
		resultText+=node.text;
	}

	//测试
	var node=new Node();
	node.text=charecters[0];
	buildBt1(node,0);

</script>
</html>